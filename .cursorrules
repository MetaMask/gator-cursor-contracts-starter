# Developing Smart Contracts for Delegation Systems

This guide focuses on creating smart contracts that work seamlessly with the MetaMask Delegation Toolkit. The key principle is to keep your contracts simple, focused on core functionality, and completely unaware of the delegation system itself.

## Core Principles

1. **Simplicity**: Contracts should focus solely on their core business logic.
2. **Owner-centric**: Use `onlyOwner` modifiers for privileged functions.
3. **Delegation-agnostic**: Contracts should not reference Delegation, DelegationManager, or mode encoding.
4. **Extensibility**: Design core functions to be easily extended through the delegation framework.
5. **Pricing and Payments**: Never include pricing, purchase, or payment logic directly in the contract. These should always be handled through delegations, assuming the owner can issue for free.

## Contract Structure

Here's an example of a basic contract structure:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyContract is ERC721, Ownable {
    constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable(msg.sender) {}

    function mint(address to, uint256 tokenId) public onlyOwner {
        _mint(to, tokenId);
    }
}
```

## Core Functions

### Minting

The `mint` function is a simple example of a core function that can be easily extended through the delegation framework.

## Using Caveat Enforcers

Caveat enforcers allow you to add specific conditions or restrictions to delegations. The MetaMask Delegation Toolkit provides several out-of-the-box caveat enforcers:

- `AllowedCalldataEnforcer.sol`: Allows restricting a range of call data to a specific value.
- `AllowedMethodsEnforcer.sol`: Allows restricting a range of call data to a specific method ID.
- `AllowedTargetsEnforcer.sol`: Allows restricting a call to a specific target address.
- `BlockNumberEnforcer.sol`: Allows specifying a valid block number range for a delegation.
- `DeployedEnforcer.sol`: Allows ensuring a CREATE2 contract is published before the delegation is used.
- `ERC20TransferAmountEnforcer.sol`: Allows specifying a maximum transfer amount for a delegation.
- `ERC20BalanceGteEnforcer.sol`: Allows specifying a minimum balance for a delegation.
- `NonceEnforcer.sol`: Allows reversible revocation, by defining a nonce that must be set to a matching value for the delegation to be valid.
- `LimitedCallsEnforcer.sol`: Allows limiting the number of times a delegation can be used.
- `TimestampEnforcer.sol`: Allows specifying a valid time range for a delegation.
- `ValueLteEnforcer.sol`: Allows specifying a maximum value for a delegation to transfer.

So any policy that is composed of those can be assumed provided already.

In the case that you need to create a custom enforcer, you can use the `CaveatEnforcer.sol` base class and write your own like this:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { CaveatEnforcer } from "@delegator/src/enforcers/CaveatEnforcer.sol";
import { Action } from "@delegator/src/utils/Types.sol";
import { IERC721 } from "@openzeppelin/contracts/token/ERC721/IERC721.sol";

contract NFTOwnershipEnforcer is CaveatEnforcer {
  struct OwnershipTerms {
    address nftContract;
    uint256 tokenId;
  }

  error NotNFTOwner(address account, address nftContract, uint256 tokenId);

  function beforeHook(
    bytes calldata _terms,
    bytes calldata,
    Action calldata,
    bytes32,
    address,
    address _redeemer
  ) external view override returns (bool) {
    return true;
  }

  function afterHook(
    bytes calldata _terms,
    bytes calldata,
    Action calldata,
    bytes32,
    address,
    address _redeemer
  ) external view override returns (bool) {
    OwnershipTerms memory terms = abi.decode(_terms, (OwnershipTerms));
    
    IERC721 nft = IERC721(terms.nftContract);
    if (nft.ownerOf(terms.tokenId) != _redeemer) {
      revert NotNFTOwner(_redeemer, terms.nftContract, terms.tokenId);
    }

    return true;
  }
}
```
This example demonstrates a custom caveat enforcer that checks NFT ownership. Here are some additional tips for working with the MetaMask Delegation Toolkit:

1. Simplify contract logic: The delegation framework allows you to move complex permission logic out of your main contracts. For example, instead of implementing complex access control in your main contract, you can use `onlyOwner` modifiers and handle permissions through delegations.

2. Leverage existing enforcers: Before creating a custom enforcer, check if any of the existing caveat enforcers (like AllowedCalldataEnforcer, BlockNumberEnforcer, ERC20TransferAmountEnforcer, etc.) can meet your needs.

3. Intent-based applications: When building intent-based apps:
   a. Identify the resource being offered (e.g., NFT minting rights)
   b. Determine the terms for offering the resource (e.g., payment, time limits)
   c. Use or create appropriate caveat enforcers

4. Handle payments via delegations: NEVER use ERC20 allowances, `payable` functions, or permit() signatures. ONLY use delegations for receiving payments.

Assume that payments are usually handled by delegation managers (enforced outside of primary application logic), and that the primary application logic is focused on the intent to share a resource, without needing to consider the payment mechanics. As a result, it should be rare that a payment is required directly in a non-CaveatEnforcer contract. If payment is required by a contract (usually a CaveatEnforcer contract), never use ERC20 allowances, or token permit() signatures. The delegation framework is meant to be a general purpose alternative to these more constrained mechanisms. If a payment is required in exchange for something, have the payment be paid as a `Delegation` + a `delegationManager address`, which can then be redeemed using the ERC-7710 `redeemDelegations()` function on that `delegationManager`:

```solidity
function redeemDelegations(
        bytes[] calldata _permissionContexts,
        ModeCode[] calldata _modes,
        bytes[] calldata _executionCallDatas
    )
```

Where `_modes` is an array of `ModeCode` values, which are used to determine the behavior of the `redeemDelegations()` function (and mode 1 is a normal internal message call). 

Calling a function using a permission context and delegation manager to performa simple send looks like this:

```solidity
import { ModeLib } from "@erc7579/lib/ModeLib.sol";
using ModeLib for ModeCode;

// Redeem ERC-7710 delegation
bytes[] memory permissionContexts_ = new bytes[](1);
permissionContexts_[0] = abi.encode(delegations_);

bytes[] memory executionCallDatas_ = new bytes[](1);
executionCallDatas_[0] = ExecutionLib.encodeSingle(recipient_, amount_, hex"");

ModeCode[] memory encodedModes_ = new ModeCode[](1);
encodedModes_[0] = ModeLib.encodeSimpleSingle();

// Attempt to redeem the delegation and make the payment
delegationManager.redeemDelegations(permissionContexts_, encodedModes_, executionCallDatas_);
```

5. Always use the delegation framework for invitations. Assume the owner can always let others use their account on their behalf with arbitrary terms.

6. Always ensure you use the `onlyOwner` modifier on any sensitive functions that should only be available to the owner. It's ok to leave this modifier off the transfer functions of a token or NFT contract. It's also ok to leave it off any function that is meant to be exposed as a public service.

7. After auto-generating a super simple contract, provide comments above each `onlyOwner` function that describes some expected/recommended delegation types for that function.
